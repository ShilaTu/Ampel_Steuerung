   1               		.file	"Shila_Ampel.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup.main,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB7:
  15               		.file 1 "Shila_Ampel.c"
   1:Shila_Ampel.c **** 
   2:Shila_Ampel.c **** /* Johannes Zink
   3:Shila_Ampel.c ****  * Shila Ampelsteuerung
   4:Shila_Ampel.c ****  * 24.02.2016
   5:Shila_Ampel.c ****  */
   6:Shila_Ampel.c **** 
   7:Shila_Ampel.c **** #include <avr/io.h>
   8:Shila_Ampel.c **** #include <avr/interrupt.h>
   9:Shila_Ampel.c **** #include <avr/pgmspace.h>
  10:Shila_Ampel.c **** #include <util/delay.h>
  11:Shila_Ampel.c **** #include "usb_debug_only.h"
  12:Shila_Ampel.c **** #include "print.h"
  13:Shila_Ampel.c **** 
  14:Shila_Ampel.c **** 
  15:Shila_Ampel.c **** // Teensy 2.0: LED is active high
  16:Shila_Ampel.c **** #if defined(__AVR_ATmega32U4__) || defined(__AVR_AT90USB1286__)
  17:Shila_Ampel.c **** #define LED_ON		(PORTD |= (1<<6))
  18:Shila_Ampel.c **** #define LED_OFF		(PORTD &= ~(1<<6))
  19:Shila_Ampel.c **** #endif
  20:Shila_Ampel.c **** 
  21:Shila_Ampel.c **** #define LED_CONFIG	(DDRD |= (1<<6))
  22:Shila_Ampel.c **** 
  23:Shila_Ampel.c **** #define RED_CFG 	(DDRD |= (1<<7))
  24:Shila_Ampel.c **** #define YELLOW_CFG 	(DDRB |= (1<<6))
  25:Shila_Ampel.c **** #define GREEN_CFG 	(DDRF |= (1<<1))
  26:Shila_Ampel.c **** 
  27:Shila_Ampel.c **** #define IN0_CFG		(DDRD &= ~(1<<0))
  28:Shila_Ampel.c **** #define IN1_CFG		(DDRD &= ~(1<<1))
  29:Shila_Ampel.c **** #define IN2_CFG		(DDRD &= ~(1<<2))
  30:Shila_Ampel.c **** 
  31:Shila_Ampel.c **** #define IN0_PORT	(PORTD &= ~(1<<0))
  32:Shila_Ampel.c **** #define IN1_PORT	(PORTD &= ~(1<<1))
  33:Shila_Ampel.c **** #define IN2_PORT	(PORTD &= ~(1<<2))
  34:Shila_Ampel.c **** 
  35:Shila_Ampel.c **** #define RED_ON		(PORTD |= (1<<7))
  36:Shila_Ampel.c **** #define RED_OFF		(PORTD &= ~(1<<7))
  37:Shila_Ampel.c **** 
  38:Shila_Ampel.c **** #define YELLOW_ON	(PORTB |= (1<<6))
  39:Shila_Ampel.c **** #define YELLOW_OFF	(PORTB &= ~(1<<6))
  40:Shila_Ampel.c **** 
  41:Shila_Ampel.c **** #define GREEN_ON	(PORTF |= (1<<1))
  42:Shila_Ampel.c **** #define GREEN_OFF	(PORTF &= ~(1<<1))
  43:Shila_Ampel.c **** 
  44:Shila_Ampel.c **** #define CPU_PRESCALE(n)	(CLKPR = 0x80, CLKPR = (n))
  45:Shila_Ampel.c **** 
  46:Shila_Ampel.c **** typedef enum {TRAFFIC, SWITCH, DEMO} state_t;
  47:Shila_Ampel.c **** typedef enum {START, RED, RYELLOW, GREEN, GYELLOW} traffic_t;
  48:Shila_Ampel.c **** 
  49:Shila_Ampel.c **** volatile unsigned int msec_cnt = 0;
  50:Shila_Ampel.c **** volatile unsigned int sec_cnt = 0;
  51:Shila_Ampel.c **** volatile unsigned int sel_trigger_cnt = 0;
  52:Shila_Ampel.c **** volatile unsigned int sel_trigger = 0;
  53:Shila_Ampel.c **** volatile unsigned int sel_led_cnt = 0;
  54:Shila_Ampel.c **** volatile unsigned int sel_y = 0;
  55:Shila_Ampel.c **** 
  56:Shila_Ampel.c **** volatile traffic_t light = RED;
  57:Shila_Ampel.c **** volatile unsigned int traffic_cnt = 0;
  58:Shila_Ampel.c **** 
  59:Shila_Ampel.c **** volatile unsigned int toggle_led = 0;
  60:Shila_Ampel.c **** 
  61:Shila_Ampel.c **** volatile unsigned int toggle_green = 0;
  62:Shila_Ampel.c **** volatile unsigned int toggle_yellow = 0;
  63:Shila_Ampel.c **** volatile unsigned int toggle_red = 0;
  64:Shila_Ampel.c **** 
  65:Shila_Ampel.c **** int main(void)
  66:Shila_Ampel.c **** {
  16               		.loc 1 66 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  67:Shila_Ampel.c **** 	// set 16 MHz system clock
  68:Shila_Ampel.c **** 	CPU_PRESCALE(0);
  22               		.loc 1 68 0
  23 0000 80E8      		ldi r24,lo8(-128)
  24 0002 8093 6100 		sts 97,r24
  25 0006 1092 6100 		sts 97,__zero_reg__
  69:Shila_Ampel.c **** 	
  70:Shila_Ampel.c **** 	// config onboard led 
  71:Shila_Ampel.c **** 	LED_CONFIG;
  26               		.loc 1 71 0
  27 000a 569A      		sbi 0xa,6
  72:Shila_Ampel.c **** 	
  73:Shila_Ampel.c **** 	// config traffic light outputs
  74:Shila_Ampel.c **** 	RED_CFG;
  28               		.loc 1 74 0
  29 000c 579A      		sbi 0xa,7
  75:Shila_Ampel.c **** 	YELLOW_CFG;
  30               		.loc 1 75 0
  31 000e 269A      		sbi 0x4,6
  76:Shila_Ampel.c **** 	GREEN_CFG;
  32               		.loc 1 76 0
  33 0010 819A      		sbi 0x10,1
  77:Shila_Ampel.c **** 	
  78:Shila_Ampel.c **** 	// config inputs
  79:Shila_Ampel.c **** 	IN0_CFG;
  34               		.loc 1 79 0
  35 0012 5098      		cbi 0xa,0
  80:Shila_Ampel.c **** 	IN1_CFG;
  36               		.loc 1 80 0
  37 0014 5198      		cbi 0xa,1
  81:Shila_Ampel.c **** 	IN2_CFG;
  38               		.loc 1 81 0
  39 0016 5298      		cbi 0xa,2
  82:Shila_Ampel.c **** 	
  83:Shila_Ampel.c **** 	// pullups off
  84:Shila_Ampel.c **** 	IN0_PORT;
  40               		.loc 1 84 0
  41 0018 5898      		cbi 0xb,0
  85:Shila_Ampel.c **** 	IN1_PORT;
  42               		.loc 1 85 0
  43 001a 5998      		cbi 0xb,1
  86:Shila_Ampel.c **** 	IN2_PORT;
  44               		.loc 1 86 0
  45 001c 5A98      		cbi 0xb,2
  87:Shila_Ampel.c **** 	
  88:Shila_Ampel.c **** 	// led off 
  89:Shila_Ampel.c **** 	LED_OFF;
  46               		.loc 1 89 0
  47 001e 5E98      		cbi 0xb,6
  90:Shila_Ampel.c **** 	
  91:Shila_Ampel.c **** 	// traffic light off
  92:Shila_Ampel.c **** 	RED_OFF;
  48               		.loc 1 92 0
  49 0020 5F98      		cbi 0xb,7
  93:Shila_Ampel.c **** 	YELLOW_OFF;
  50               		.loc 1 93 0
  51 0022 2E98      		cbi 0x5,6
  94:Shila_Ampel.c **** 	GREEN_OFF;
  52               		.loc 1 94 0
  53 0024 8998      		cbi 0x11,1
  95:Shila_Ampel.c **** 	
  96:Shila_Ampel.c **** 	// all lights on
  97:Shila_Ampel.c **** 	LED_ON;
  54               		.loc 1 97 0
  55 0026 5E9A      		sbi 0xb,6
  98:Shila_Ampel.c **** 	RED_ON;
  56               		.loc 1 98 0
  57 0028 5F9A      		sbi 0xb,7
  99:Shila_Ampel.c **** 	YELLOW_ON;
  58               		.loc 1 99 0
  59 002a 2E9A      		sbi 0x5,6
 100:Shila_Ampel.c **** 	GREEN_ON;
  60               		.loc 1 100 0
  61 002c 899A      		sbi 0x11,1
  62               	.LVL0:
  63               	.LBB14:
  64               	.LBB15:
  65               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  66               		.loc 2 164 0
  67 002e 2FEF      		ldi r18,lo8(3199999)
  68 0030 73ED      		ldi r23,hi8(3199999)
  69 0032 80E3      		ldi r24,hlo8(3199999)
  70 0034 2150      		1: subi r18,1
  71 0036 7040      		sbci r23,0
  72 0038 8040      		sbci r24,0
  73 003a 01F4      		brne 1b
  74 003c 00C0      		rjmp .
  75 003e 0000      		nop
  76               	.LBE15:
  77               	.LBE14:
 101:Shila_Ampel.c **** 	
 102:Shila_Ampel.c **** 	_delay_ms(1000);
 103:Shila_Ampel.c **** 	
 104:Shila_Ampel.c **** 	// all traffic lights off
 105:Shila_Ampel.c **** 	RED_OFF;
  78               		.loc 1 105 0
  79 0040 5F98      		cbi 0xb,7
 106:Shila_Ampel.c **** 	YELLOW_OFF;
  80               		.loc 1 106 0
  81 0042 2E98      		cbi 0x5,6
 107:Shila_Ampel.c **** 	GREEN_OFF;
  82               		.loc 1 107 0
  83 0044 8998      		cbi 0x11,1
  84               	.LVL1:
  85               	.LBB16:
  86               	.LBB17:
  87               		.loc 2 164 0
  88 0046 9FEF      		ldi r25,lo8(3199999)
  89 0048 23ED      		ldi r18,hi8(3199999)
  90 004a 70E3      		ldi r23,hlo8(3199999)
  91 004c 9150      		1: subi r25,1
  92 004e 2040      		sbci r18,0
  93 0050 7040      		sbci r23,0
  94 0052 01F4      		brne 1b
  95 0054 00C0      		rjmp .
  96 0056 0000      		nop
  97               	.LBE17:
  98               	.LBE16:
 108:Shila_Ampel.c **** 
 109:Shila_Ampel.c **** 	_delay_ms(1000);
 110:Shila_Ampel.c **** 	
 111:Shila_Ampel.c **** 	// initialize USB, but don't wait for the host to
 112:Shila_Ampel.c **** 	// configure.
 113:Shila_Ampel.c **** 	usb_init();
  99               		.loc 1 113 0
 100 0058 0E94 0000 		call usb_init
 101               	.LVL2:
 114:Shila_Ampel.c **** 
 115:Shila_Ampel.c **** 	// start sequence
 116:Shila_Ampel.c **** 	RED_ON;
 102               		.loc 1 116 0
 103 005c 5F9A      		sbi 0xb,7
 104               	.LVL3:
 105               	.LBB18:
 106               	.LBB19:
 107               		.loc 2 164 0
 108 005e 8FEF      		ldi r24,lo8(639999)
 109 0060 93EC      		ldi r25,hi8(639999)
 110 0062 29E0      		ldi r18,hlo8(639999)
 111 0064 8150      		1: subi r24,1
 112 0066 9040      		sbci r25,0
 113 0068 2040      		sbci r18,0
 114 006a 01F4      		brne 1b
 115 006c 00C0      		rjmp .
 116 006e 0000      		nop
 117               	.LBE19:
 118               	.LBE18:
 117:Shila_Ampel.c **** 
 118:Shila_Ampel.c **** 	_delay_ms(200);
 119:Shila_Ampel.c **** 	
 120:Shila_Ampel.c **** 	RED_OFF;
 119               		.loc 1 120 0
 120 0070 5F98      		cbi 0xb,7
 121:Shila_Ampel.c **** 	YELLOW_ON;
 121               		.loc 1 121 0
 122 0072 2E9A      		sbi 0x5,6
 123               	.LVL4:
 124               	.LBB20:
 125               	.LBB21:
 126               		.loc 2 164 0
 127 0074 7FEF      		ldi r23,lo8(639999)
 128 0076 83EC      		ldi r24,hi8(639999)
 129 0078 99E0      		ldi r25,hlo8(639999)
 130 007a 7150      		1: subi r23,1
 131 007c 8040      		sbci r24,0
 132 007e 9040      		sbci r25,0
 133 0080 01F4      		brne 1b
 134 0082 00C0      		rjmp .
 135 0084 0000      		nop
 136               	.LBE21:
 137               	.LBE20:
 122:Shila_Ampel.c **** 	
 123:Shila_Ampel.c **** 	_delay_ms(200);
 124:Shila_Ampel.c **** 	
 125:Shila_Ampel.c **** 	RED_OFF;
 138               		.loc 1 125 0
 139 0086 5F98      		cbi 0xb,7
 126:Shila_Ampel.c **** 	YELLOW_OFF;
 140               		.loc 1 126 0
 141 0088 2E98      		cbi 0x5,6
 127:Shila_Ampel.c **** 	GREEN_ON;
 142               		.loc 1 127 0
 143 008a 899A      		sbi 0x11,1
 144               	.LVL5:
 145               	.LBB22:
 146               	.LBB23:
 147               		.loc 2 164 0
 148 008c 2FEF      		ldi r18,lo8(639999)
 149 008e 73EC      		ldi r23,hi8(639999)
 150 0090 89E0      		ldi r24,hlo8(639999)
 151 0092 2150      		1: subi r18,1
 152 0094 7040      		sbci r23,0
 153 0096 8040      		sbci r24,0
 154 0098 01F4      		brne 1b
 155 009a 00C0      		rjmp .
 156 009c 0000      		nop
 157               	.LBE23:
 158               	.LBE22:
 128:Shila_Ampel.c **** 	
 129:Shila_Ampel.c **** 	_delay_ms(200);
 130:Shila_Ampel.c **** 	
 131:Shila_Ampel.c **** 	RED_OFF;
 159               		.loc 1 131 0
 160 009e 5F98      		cbi 0xb,7
 132:Shila_Ampel.c **** 	YELLOW_ON;
 161               		.loc 1 132 0
 162 00a0 2E9A      		sbi 0x5,6
 133:Shila_Ampel.c **** 	GREEN_OFF;
 163               		.loc 1 133 0
 164 00a2 8998      		cbi 0x11,1
 165               	.LVL6:
 166               	.LBB24:
 167               	.LBB25:
 168               		.loc 2 164 0
 169 00a4 9FEF      		ldi r25,lo8(639999)
 170 00a6 23EC      		ldi r18,hi8(639999)
 171 00a8 79E0      		ldi r23,hlo8(639999)
 172 00aa 9150      		1: subi r25,1
 173 00ac 2040      		sbci r18,0
 174 00ae 7040      		sbci r23,0
 175 00b0 01F4      		brne 1b
 176 00b2 00C0      		rjmp .
 177 00b4 0000      		nop
 178               	.LBE25:
 179               	.LBE24:
 134:Shila_Ampel.c **** 	
 135:Shila_Ampel.c **** 	_delay_ms(200);
 136:Shila_Ampel.c **** 	
 137:Shila_Ampel.c **** 	RED_ON;
 180               		.loc 1 137 0
 181 00b6 5F9A      		sbi 0xb,7
 138:Shila_Ampel.c **** 	YELLOW_OFF;
 182               		.loc 1 138 0
 183 00b8 2E98      		cbi 0x5,6
 139:Shila_Ampel.c **** 	GREEN_OFF;
 184               		.loc 1 139 0
 185 00ba 8998      		cbi 0x11,1
 186               	.LVL7:
 140:Shila_Ampel.c **** 
 141:Shila_Ampel.c **** 	// init state = IDLE
 142:Shila_Ampel.c **** 	state_t state = TRAFFIC;
 143:Shila_Ampel.c **** 	light = START;
 187               		.loc 1 143 0
 188 00bc 1092 0000 		sts light,__zero_reg__
 144:Shila_Ampel.c **** 	
 145:Shila_Ampel.c **** 	sel_trigger_cnt = 0;
 189               		.loc 1 145 0
 190 00c0 1092 0000 		sts sel_trigger_cnt+1,__zero_reg__
 191 00c4 1092 0000 		sts sel_trigger_cnt,__zero_reg__
 146:Shila_Ampel.c **** 	sel_led_cnt = 0;
 192               		.loc 1 146 0
 193 00c8 1092 0000 		sts sel_led_cnt+1,__zero_reg__
 194 00cc 1092 0000 		sts sel_led_cnt,__zero_reg__
 147:Shila_Ampel.c **** 
 148:Shila_Ampel.c **** 	// timer0 config
 149:Shila_Ampel.c **** 	TCCR0A |= (1<<WGM01);
 195               		.loc 1 149 0
 196 00d0 84B5      		in r24,0x24
 197 00d2 8260      		ori r24,lo8(2)
 198 00d4 84BD      		out 0x24,r24
 150:Shila_Ampel.c **** 	// timer0 start
 151:Shila_Ampel.c **** 	TCCR0B |= (1<<CS01) | (1<<CS00);
 199               		.loc 1 151 0
 200 00d6 85B5      		in r24,0x25
 201 00d8 8360      		ori r24,lo8(3)
 202 00da 85BD      		out 0x25,r24
 152:Shila_Ampel.c **** 	// timer0 compare value -> 1ms tick
 153:Shila_Ampel.c **** 	OCR0A = 250-1;
 203               		.loc 1 153 0
 204 00dc 89EF      		ldi r24,lo8(-7)
 205 00de 87BD      		out 0x27,r24
 154:Shila_Ampel.c **** 	// timer0 interrupt config 
 155:Shila_Ampel.c **** 	TIMSK0 |= (1<<OCIE0A);
 206               		.loc 1 155 0
 207 00e0 8091 6E00 		lds r24,110
 208 00e4 8260      		ori r24,lo8(2)
 209 00e6 8093 6E00 		sts 110,r24
 156:Shila_Ampel.c **** 	
 157:Shila_Ampel.c **** 	// int0 interrupt config
 158:Shila_Ampel.c **** 	// enable INT0	
 159:Shila_Ampel.c **** 	EICRA |= (1<<ISC01);
 210               		.loc 1 159 0
 211 00ea 8091 6900 		lds r24,105
 212 00ee 8260      		ori r24,lo8(2)
 213 00f0 8093 6900 		sts 105,r24
 160:Shila_Ampel.c **** 	EICRA |= (1<<ISC00);
 214               		.loc 1 160 0
 215 00f4 8091 6900 		lds r24,105
 216 00f8 8160      		ori r24,lo8(1)
 217 00fa 8093 6900 		sts 105,r24
 161:Shila_Ampel.c **** 	// config INT1	
 162:Shila_Ampel.c **** 	EICRA |= (1<<ISC11);
 218               		.loc 1 162 0
 219 00fe 8091 6900 		lds r24,105
 220 0102 8860      		ori r24,lo8(8)
 221 0104 8093 6900 		sts 105,r24
 163:Shila_Ampel.c **** 	EICRA |= (1<<ISC10);
 222               		.loc 1 163 0
 223 0108 8091 6900 		lds r24,105
 224 010c 8460      		ori r24,lo8(4)
 225 010e 8093 6900 		sts 105,r24
 164:Shila_Ampel.c **** 	// config INT2	
 165:Shila_Ampel.c **** 	EICRA |= (1<<ISC21);
 226               		.loc 1 165 0
 227 0112 8091 6900 		lds r24,105
 228 0116 8062      		ori r24,lo8(32)
 229 0118 8093 6900 		sts 105,r24
 166:Shila_Ampel.c **** 	EICRA |= (1<<ISC20);
 230               		.loc 1 166 0
 231 011c 8091 6900 		lds r24,105
 232 0120 8061      		ori r24,lo8(16)
 233 0122 8093 6900 		sts 105,r24
 167:Shila_Ampel.c **** 	// enable int0 & int1 
 168:Shila_Ampel.c **** 	EIMSK |= (1<<INT0) | (1<<INT1) | (1<<INT2);	
 234               		.loc 1 168 0
 235 0126 8DB3      		in r24,0x1d
 236 0128 8760      		ori r24,lo8(7)
 237 012a 8DBB      		out 0x1d,r24
 169:Shila_Ampel.c **** 
 170:Shila_Ampel.c **** 		
 171:Shila_Ampel.c **** 	// enabel global interrupts
 172:Shila_Ampel.c **** 	sei();
 238               		.loc 1 172 0
 239               	/* #APP */
 240               	 ;  172 "Shila_Ampel.c" 1
 241 012c 7894      		sei
 242               	 ;  0 "" 2
 142:Shila_Ampel.c **** 	state_t state = TRAFFIC;
 243               		.loc 1 142 0
 244               	/* #NOAPP */
 245 012e 20E0      		ldi r18,0
 173:Shila_Ampel.c **** 
 174:Shila_Ampel.c **** 	while (1) {
 175:Shila_Ampel.c **** 	
 176:Shila_Ampel.c **** 		switch(state)
 177:Shila_Ampel.c **** 		{
 178:Shila_Ampel.c **** 			case TRAFFIC:
 179:Shila_Ampel.c **** 			{
 180:Shila_Ampel.c **** 				if(light == START)
 181:Shila_Ampel.c **** 				{
 182:Shila_Ampel.c **** 					YELLOW_OFF;
 183:Shila_Ampel.c **** 					GREEN_OFF;
 184:Shila_Ampel.c **** 					light = RED;
 185:Shila_Ampel.c **** 					RED_ON;
 186:Shila_Ampel.c **** 				}
 187:Shila_Ampel.c **** 					
 188:Shila_Ampel.c **** 				if(light == RED)
 189:Shila_Ampel.c **** 				{
 190:Shila_Ampel.c **** 					if(traffic_cnt == 40000)
 191:Shila_Ampel.c **** 					{
 192:Shila_Ampel.c **** 						cli();
 193:Shila_Ampel.c **** 						RED_ON;
 194:Shila_Ampel.c **** 						YELLOW_ON;
 195:Shila_Ampel.c **** 						traffic_cnt = 0;
 196:Shila_Ampel.c **** 						light = RYELLOW;
 197:Shila_Ampel.c **** 						sei();
 198:Shila_Ampel.c **** 					}
 199:Shila_Ampel.c **** 				}
 200:Shila_Ampel.c **** 				
 201:Shila_Ampel.c **** 				if(light == RYELLOW)
 202:Shila_Ampel.c **** 				{
 203:Shila_Ampel.c **** 					if(traffic_cnt == 3000)
 204:Shila_Ampel.c **** 					{
 205:Shila_Ampel.c **** 						cli();
 206:Shila_Ampel.c **** 						RED_OFF;
 207:Shila_Ampel.c **** 						YELLOW_OFF;
 208:Shila_Ampel.c **** 						GREEN_ON;
 209:Shila_Ampel.c **** 						traffic_cnt = 0;
 210:Shila_Ampel.c **** 						light = GREEN;
 211:Shila_Ampel.c **** 						sei();
 212:Shila_Ampel.c **** 					}
 213:Shila_Ampel.c **** 				}
 214:Shila_Ampel.c **** 				
 215:Shila_Ampel.c **** 				if(light == GREEN)
 216:Shila_Ampel.c **** 				{
 217:Shila_Ampel.c **** 					if(traffic_cnt == 40000)
 218:Shila_Ampel.c **** 					{
 219:Shila_Ampel.c **** 						cli();
 220:Shila_Ampel.c **** 						GREEN_OFF;
 221:Shila_Ampel.c **** 						YELLOW_ON;
 222:Shila_Ampel.c **** 						traffic_cnt = 0;
 223:Shila_Ampel.c **** 						light = GYELLOW;
 224:Shila_Ampel.c **** 						sei();
 225:Shila_Ampel.c **** 					}
 226:Shila_Ampel.c **** 				}
 227:Shila_Ampel.c **** 				
 228:Shila_Ampel.c **** 				if(light == GYELLOW)
 229:Shila_Ampel.c **** 				{
 230:Shila_Ampel.c **** 					if(traffic_cnt == 3000)
 231:Shila_Ampel.c **** 					{
 232:Shila_Ampel.c **** 						cli();
 233:Shila_Ampel.c **** 						YELLOW_OFF;
 234:Shila_Ampel.c **** 						RED_ON;
 235:Shila_Ampel.c **** 						traffic_cnt = 0;
 236:Shila_Ampel.c **** 						light = RED;
 246               		.loc 1 236 0
 247 0130 31E0      		ldi r19,lo8(1)
 223:Shila_Ampel.c **** 						light = GYELLOW;
 248               		.loc 1 223 0
 249 0132 44E0      		ldi r20,lo8(4)
 210:Shila_Ampel.c **** 						light = GREEN;
 250               		.loc 1 210 0
 251 0134 53E0      		ldi r21,lo8(3)
 196:Shila_Ampel.c **** 						light = RYELLOW;
 252               		.loc 1 196 0
 253 0136 62E0      		ldi r22,lo8(2)
 254               	.LVL8:
 255               	.L2:
 176:Shila_Ampel.c **** 		switch(state)
 256               		.loc 1 176 0
 257 0138 2130      		cpi r18,lo8(1)
 258 013a 01F4      		brne .+2
 259 013c 00C0      		rjmp .L4
 180:Shila_Ampel.c **** 				if(light == START)
 260               		.loc 1 180 0
 261 013e 8091 0000 		lds r24,light
 262 0142 8111      		cpse r24,__zero_reg__
 263 0144 00C0      		rjmp .L5
 182:Shila_Ampel.c **** 					YELLOW_OFF;
 264               		.loc 1 182 0
 265 0146 2E98      		cbi 0x5,6
 183:Shila_Ampel.c **** 					GREEN_OFF;
 266               		.loc 1 183 0
 267 0148 8998      		cbi 0x11,1
 184:Shila_Ampel.c **** 					light = RED;
 268               		.loc 1 184 0
 269 014a 3093 0000 		sts light,r19
 185:Shila_Ampel.c **** 					RED_ON;
 270               		.loc 1 185 0
 271 014e 5F9A      		sbi 0xb,7
 272               	.L5:
 188:Shila_Ampel.c **** 				if(light == RED)
 273               		.loc 1 188 0
 274 0150 8091 0000 		lds r24,light
 275 0154 8130      		cpi r24,lo8(1)
 276 0156 01F4      		brne .L6
 190:Shila_Ampel.c **** 					if(traffic_cnt == 40000)
 277               		.loc 1 190 0
 278 0158 8091 0000 		lds r24,traffic_cnt
 279 015c 9091 0000 		lds r25,traffic_cnt+1
 280 0160 8034      		cpi r24,64
 281 0162 9C49      		sbci r25,-100
 282 0164 01F4      		brne .L6
 192:Shila_Ampel.c **** 						cli();
 283               		.loc 1 192 0
 284               	/* #APP */
 285               	 ;  192 "Shila_Ampel.c" 1
 286 0166 F894      		cli
 287               	 ;  0 "" 2
 193:Shila_Ampel.c **** 						RED_ON;
 288               		.loc 1 193 0
 289               	/* #NOAPP */
 290 0168 5F9A      		sbi 0xb,7
 194:Shila_Ampel.c **** 						YELLOW_ON;
 291               		.loc 1 194 0
 292 016a 2E9A      		sbi 0x5,6
 195:Shila_Ampel.c **** 						traffic_cnt = 0;
 293               		.loc 1 195 0
 294 016c 1092 0000 		sts traffic_cnt+1,__zero_reg__
 295 0170 1092 0000 		sts traffic_cnt,__zero_reg__
 196:Shila_Ampel.c **** 						light = RYELLOW;
 296               		.loc 1 196 0
 297 0174 6093 0000 		sts light,r22
 197:Shila_Ampel.c **** 						sei();
 298               		.loc 1 197 0
 299               	/* #APP */
 300               	 ;  197 "Shila_Ampel.c" 1
 301 0178 7894      		sei
 302               	 ;  0 "" 2
 303               	/* #NOAPP */
 304               	.L6:
 201:Shila_Ampel.c **** 				if(light == RYELLOW)
 305               		.loc 1 201 0
 306 017a 8091 0000 		lds r24,light
 307 017e 8230      		cpi r24,lo8(2)
 308 0180 01F4      		brne .L7
 203:Shila_Ampel.c **** 					if(traffic_cnt == 3000)
 309               		.loc 1 203 0
 310 0182 8091 0000 		lds r24,traffic_cnt
 311 0186 9091 0000 		lds r25,traffic_cnt+1
 312 018a 883B      		cpi r24,-72
 313 018c 9B40      		sbci r25,11
 314 018e 01F4      		brne .L7
 205:Shila_Ampel.c **** 						cli();
 315               		.loc 1 205 0
 316               	/* #APP */
 317               	 ;  205 "Shila_Ampel.c" 1
 318 0190 F894      		cli
 319               	 ;  0 "" 2
 206:Shila_Ampel.c **** 						RED_OFF;
 320               		.loc 1 206 0
 321               	/* #NOAPP */
 322 0192 5F98      		cbi 0xb,7
 207:Shila_Ampel.c **** 						YELLOW_OFF;
 323               		.loc 1 207 0
 324 0194 2E98      		cbi 0x5,6
 208:Shila_Ampel.c **** 						GREEN_ON;
 325               		.loc 1 208 0
 326 0196 899A      		sbi 0x11,1
 209:Shila_Ampel.c **** 						traffic_cnt = 0;
 327               		.loc 1 209 0
 328 0198 1092 0000 		sts traffic_cnt+1,__zero_reg__
 329 019c 1092 0000 		sts traffic_cnt,__zero_reg__
 210:Shila_Ampel.c **** 						light = GREEN;
 330               		.loc 1 210 0
 331 01a0 5093 0000 		sts light,r21
 211:Shila_Ampel.c **** 						sei();
 332               		.loc 1 211 0
 333               	/* #APP */
 334               	 ;  211 "Shila_Ampel.c" 1
 335 01a4 7894      		sei
 336               	 ;  0 "" 2
 337               	/* #NOAPP */
 338               	.L7:
 215:Shila_Ampel.c **** 				if(light == GREEN)
 339               		.loc 1 215 0
 340 01a6 8091 0000 		lds r24,light
 341 01aa 8330      		cpi r24,lo8(3)
 342 01ac 01F4      		brne .L8
 217:Shila_Ampel.c **** 					if(traffic_cnt == 40000)
 343               		.loc 1 217 0
 344 01ae 8091 0000 		lds r24,traffic_cnt
 345 01b2 9091 0000 		lds r25,traffic_cnt+1
 346 01b6 8034      		cpi r24,64
 347 01b8 9C49      		sbci r25,-100
 348 01ba 01F4      		brne .L8
 219:Shila_Ampel.c **** 						cli();
 349               		.loc 1 219 0
 350               	/* #APP */
 351               	 ;  219 "Shila_Ampel.c" 1
 352 01bc F894      		cli
 353               	 ;  0 "" 2
 220:Shila_Ampel.c **** 						GREEN_OFF;
 354               		.loc 1 220 0
 355               	/* #NOAPP */
 356 01be 8998      		cbi 0x11,1
 221:Shila_Ampel.c **** 						YELLOW_ON;
 357               		.loc 1 221 0
 358 01c0 2E9A      		sbi 0x5,6
 222:Shila_Ampel.c **** 						traffic_cnt = 0;
 359               		.loc 1 222 0
 360 01c2 1092 0000 		sts traffic_cnt+1,__zero_reg__
 361 01c6 1092 0000 		sts traffic_cnt,__zero_reg__
 223:Shila_Ampel.c **** 						light = GYELLOW;
 362               		.loc 1 223 0
 363 01ca 4093 0000 		sts light,r20
 224:Shila_Ampel.c **** 						sei();
 364               		.loc 1 224 0
 365               	/* #APP */
 366               	 ;  224 "Shila_Ampel.c" 1
 367 01ce 7894      		sei
 368               	 ;  0 "" 2
 369               	/* #NOAPP */
 370               	.L8:
 228:Shila_Ampel.c **** 				if(light == GYELLOW)
 371               		.loc 1 228 0
 372 01d0 8091 0000 		lds r24,light
 373 01d4 8430      		cpi r24,lo8(4)
 374 01d6 01F4      		brne .L16
 230:Shila_Ampel.c **** 					if(traffic_cnt == 3000)
 375               		.loc 1 230 0
 376 01d8 8091 0000 		lds r24,traffic_cnt
 377 01dc 9091 0000 		lds r25,traffic_cnt+1
 378 01e0 883B      		cpi r24,-72
 379 01e2 9B40      		sbci r25,11
 380 01e4 01F4      		brne .L16
 232:Shila_Ampel.c **** 						cli();
 381               		.loc 1 232 0
 382               	/* #APP */
 383               	 ;  232 "Shila_Ampel.c" 1
 384 01e6 F894      		cli
 385               	 ;  0 "" 2
 233:Shila_Ampel.c **** 						YELLOW_OFF;
 386               		.loc 1 233 0
 387               	/* #NOAPP */
 388 01e8 2E98      		cbi 0x5,6
 234:Shila_Ampel.c **** 						RED_ON;
 389               		.loc 1 234 0
 390 01ea 5F9A      		sbi 0xb,7
 235:Shila_Ampel.c **** 						traffic_cnt = 0;
 391               		.loc 1 235 0
 392 01ec 1092 0000 		sts traffic_cnt+1,__zero_reg__
 393 01f0 1092 0000 		sts traffic_cnt,__zero_reg__
 394               		.loc 1 236 0
 395 01f4 3093 0000 		sts light,r19
 237:Shila_Ampel.c **** 						sei();
 396               		.loc 1 237 0
 397               	/* #APP */
 398               	 ;  237 "Shila_Ampel.c" 1
 399 01f8 7894      		sei
 400               	 ;  0 "" 2
 401               	.LVL9:
 402               	/* #NOAPP */
 403 01fa 00C0      		rjmp .L16
 404               	.LVL10:
 405               	.L4:
 238:Shila_Ampel.c **** 					}
 239:Shila_Ampel.c **** 				}
 240:Shila_Ampel.c **** 				
 241:Shila_Ampel.c **** 				state = TRAFFIC;
 242:Shila_Ampel.c **** 				break;
 243:Shila_Ampel.c **** 			}
 244:Shila_Ampel.c **** 			case SWITCH:
 245:Shila_Ampel.c **** 			{
 246:Shila_Ampel.c **** 				if(toggle_red == 1)
 406               		.loc 1 246 0
 407 01fc 8091 0000 		lds r24,toggle_red
 408 0200 9091 0000 		lds r25,toggle_red+1
 409 0204 0197      		sbiw r24,1
 410 0206 01F4      		brne .L10
 247:Shila_Ampel.c **** 				{
 248:Shila_Ampel.c **** 					RED_ON;
 411               		.loc 1 248 0
 412 0208 5F9A      		sbi 0xb,7
 249:Shila_Ampel.c **** 					YELLOW_OFF;
 413               		.loc 1 249 0
 414 020a 2E98      		cbi 0x5,6
 250:Shila_Ampel.c **** 					GREEN_OFF;
 415               		.loc 1 250 0
 416 020c 8998      		cbi 0x11,1
 251:Shila_Ampel.c **** 					toggle_red = 0;
 417               		.loc 1 251 0
 418 020e 1092 0000 		sts toggle_red+1,__zero_reg__
 419 0212 1092 0000 		sts toggle_red,__zero_reg__
 420 0216 00C0      		rjmp .L9
 421               	.L10:
 252:Shila_Ampel.c **** 				}
 253:Shila_Ampel.c **** 				else if(toggle_yellow == 1)
 422               		.loc 1 253 0
 423 0218 8091 0000 		lds r24,toggle_yellow
 424 021c 9091 0000 		lds r25,toggle_yellow+1
 425 0220 0197      		sbiw r24,1
 426 0222 01F4      		brne .L11
 254:Shila_Ampel.c **** 				{
 255:Shila_Ampel.c **** 					RED_OFF;
 427               		.loc 1 255 0
 428 0224 5F98      		cbi 0xb,7
 256:Shila_Ampel.c **** 					YELLOW_ON;
 429               		.loc 1 256 0
 430 0226 2E9A      		sbi 0x5,6
 257:Shila_Ampel.c **** 					GREEN_OFF;
 431               		.loc 1 257 0
 432 0228 8998      		cbi 0x11,1
 258:Shila_Ampel.c **** 					toggle_yellow = 0;
 433               		.loc 1 258 0
 434 022a 1092 0000 		sts toggle_yellow+1,__zero_reg__
 435 022e 1092 0000 		sts toggle_yellow,__zero_reg__
 436 0232 00C0      		rjmp .L9
 437               	.L11:
 259:Shila_Ampel.c **** 				}
 260:Shila_Ampel.c **** 				else if(toggle_green == 1)
 438               		.loc 1 260 0
 439 0234 8091 0000 		lds r24,toggle_green
 440 0238 9091 0000 		lds r25,toggle_green+1
 441 023c 0197      		sbiw r24,1
 442 023e 01F4      		brne .L9
 261:Shila_Ampel.c **** 				{
 262:Shila_Ampel.c **** 					RED_OFF;
 443               		.loc 1 262 0
 444 0240 5F98      		cbi 0xb,7
 263:Shila_Ampel.c **** 					YELLOW_OFF;
 445               		.loc 1 263 0
 446 0242 2E98      		cbi 0x5,6
 264:Shila_Ampel.c **** 					GREEN_ON;
 447               		.loc 1 264 0
 448 0244 899A      		sbi 0x11,1
 265:Shila_Ampel.c **** 					toggle_green = 0;
 449               		.loc 1 265 0
 450 0246 1092 0000 		sts toggle_green+1,__zero_reg__
 451 024a 1092 0000 		sts toggle_green,__zero_reg__
 452 024e 00C0      		rjmp .L9
 453               	.L16:
 454               	.LVL11:
 241:Shila_Ampel.c **** 				state = TRAFFIC;
 455               		.loc 1 241 0
 456 0250 20E0      		ldi r18,0
 457               	.LVL12:
 458               	.L9:
 266:Shila_Ampel.c **** 				}
 267:Shila_Ampel.c **** 				
 268:Shila_Ampel.c **** 				state = SWITCH;
 269:Shila_Ampel.c **** 				break;
 270:Shila_Ampel.c **** 			}
 271:Shila_Ampel.c **** 			case DEMO:
 272:Shila_Ampel.c **** 			{
 273:Shila_Ampel.c **** 				
 274:Shila_Ampel.c **** 				break;
 275:Shila_Ampel.c **** 			}
 276:Shila_Ampel.c **** 			default:
 277:Shila_Ampel.c **** 			{
 278:Shila_Ampel.c **** 				
 279:Shila_Ampel.c **** 				break;
 280:Shila_Ampel.c **** 			}
 281:Shila_Ampel.c **** 		
 282:Shila_Ampel.c **** 		}
 283:Shila_Ampel.c **** 		
 284:Shila_Ampel.c **** 		if(sel_trigger == 1 && sel_trigger_cnt == 3000 && (PIND & (1<<2)))
 459               		.loc 1 284 0
 460 0252 8091 0000 		lds r24,sel_trigger
 461 0256 9091 0000 		lds r25,sel_trigger+1
 462 025a 0197      		sbiw r24,1
 463 025c 01F4      		brne .L12
 464               		.loc 1 284 0 is_stmt 0 discriminator 1
 465 025e 8091 0000 		lds r24,sel_trigger_cnt
 466 0262 9091 0000 		lds r25,sel_trigger_cnt+1
 467 0266 883B      		cpi r24,-72
 468 0268 9B40      		sbci r25,11
 469 026a 01F4      		brne .L12
 470 026c 4A9B      		sbis 0x9,2
 471 026e 00C0      		rjmp .L12
 285:Shila_Ampel.c **** 		{
 286:Shila_Ampel.c **** 			if(state == SWITCH)
 472               		.loc 1 286 0 is_stmt 1
 473 0270 2130      		cpi r18,lo8(1)
 474 0272 01F4      		brne .L17
 287:Shila_Ampel.c **** 			{
 288:Shila_Ampel.c **** 				RED_OFF;
 475               		.loc 1 288 0
 476 0274 5F98      		cbi 0xb,7
 289:Shila_Ampel.c **** 				YELLOW_OFF;
 477               		.loc 1 289 0
 478 0276 2E98      		cbi 0x5,6
 290:Shila_Ampel.c **** 				GREEN_OFF;
 479               		.loc 1 290 0
 480 0278 8998      		cbi 0x11,1
 481               	.LVL13:
 291:Shila_Ampel.c **** 				state = TRAFFIC;
 292:Shila_Ampel.c **** 				light = START;
 482               		.loc 1 292 0
 483 027a 1092 0000 		sts light,__zero_reg__
 291:Shila_Ampel.c **** 				state = TRAFFIC;
 484               		.loc 1 291 0
 485 027e 20E0      		ldi r18,0
 486 0280 00C0      		rjmp .L13
 487               	.LVL14:
 488               	.L17:
 293:Shila_Ampel.c **** 			}
 294:Shila_Ampel.c **** 			else if(state == TRAFFIC)
 295:Shila_Ampel.c **** 			{
 296:Shila_Ampel.c **** 				state = SWITCH;
 489               		.loc 1 296 0
 490 0282 21E0      		ldi r18,lo8(1)
 491               	.LVL15:
 492               	.L13:
 297:Shila_Ampel.c **** 			}
 298:Shila_Ampel.c **** 			
 299:Shila_Ampel.c **** 			sel_trigger_cnt = 0;
 493               		.loc 1 299 0
 494 0284 1092 0000 		sts sel_trigger_cnt+1,__zero_reg__
 495 0288 1092 0000 		sts sel_trigger_cnt,__zero_reg__
 300:Shila_Ampel.c **** 			sel_trigger = 0;
 496               		.loc 1 300 0
 497 028c 1092 0000 		sts sel_trigger+1,__zero_reg__
 498 0290 1092 0000 		sts sel_trigger,__zero_reg__
 499               	.L12:
 301:Shila_Ampel.c **** 		}
 302:Shila_Ampel.c **** 		
 303:Shila_Ampel.c **** 		if(sel_trigger == 1 && sel_trigger_cnt < 3000)
 500               		.loc 1 303 0
 501 0294 8091 0000 		lds r24,sel_trigger
 502 0298 9091 0000 		lds r25,sel_trigger+1
 503 029c 0197      		sbiw r24,1
 504 029e 01F0      		breq .+2
 505 02a0 00C0      		rjmp .L2
 506               		.loc 1 303 0 is_stmt 0 discriminator 1
 507 02a2 8091 0000 		lds r24,sel_trigger_cnt
 508 02a6 9091 0000 		lds r25,sel_trigger_cnt+1
 509 02aa 883B      		cpi r24,-72
 510 02ac 9B40      		sbci r25,11
 511 02ae 00F0      		brlo .+2
 512 02b0 00C0      		rjmp .L2
 304:Shila_Ampel.c **** 		{
 305:Shila_Ampel.c **** 			if(PIND & (1<<2))
 513               		.loc 1 305 0 is_stmt 1
 514 02b2 4A99      		sbic 0x9,2
 515 02b4 00C0      		rjmp .L2
 306:Shila_Ampel.c **** 			{
 307:Shila_Ampel.c **** 			}
 308:Shila_Ampel.c **** 			else
 309:Shila_Ampel.c **** 			{
 310:Shila_Ampel.c **** 				sel_trigger_cnt = 0;
 516               		.loc 1 310 0
 517 02b6 1092 0000 		sts sel_trigger_cnt+1,__zero_reg__
 518 02ba 1092 0000 		sts sel_trigger_cnt,__zero_reg__
 311:Shila_Ampel.c **** 				sel_trigger = 0;
 519               		.loc 1 311 0
 520 02be 1092 0000 		sts sel_trigger+1,__zero_reg__
 521 02c2 1092 0000 		sts sel_trigger,__zero_reg__
 522 02c6 00C0      		rjmp .L2
 523               		.cfi_endproc
 524               	.LFE7:
 526               		.section	.text.__vector_21,"ax",@progbits
 527               	.global	__vector_21
 529               	__vector_21:
 530               	.LFB8:
 312:Shila_Ampel.c **** 			}
 313:Shila_Ampel.c **** 		}
 314:Shila_Ampel.c **** 	}
 315:Shila_Ampel.c **** }
 316:Shila_Ampel.c **** 
 317:Shila_Ampel.c **** ISR (TIMER0_COMPA_vect)
 318:Shila_Ampel.c **** {
 531               		.loc 1 318 0
 532               		.cfi_startproc
 533 0000 1F92      		push r1
 534               	.LCFI0:
 535               		.cfi_def_cfa_offset 3
 536               		.cfi_offset 1, -2
 537 0002 0F92      		push r0
 538               	.LCFI1:
 539               		.cfi_def_cfa_offset 4
 540               		.cfi_offset 0, -3
 541 0004 0FB6      		in r0,__SREG__
 542 0006 0F92      		push r0
 543 0008 1124      		clr __zero_reg__
 544 000a 2F93      		push r18
 545               	.LCFI2:
 546               		.cfi_def_cfa_offset 5
 547               		.cfi_offset 18, -4
 548 000c 8F93      		push r24
 549               	.LCFI3:
 550               		.cfi_def_cfa_offset 6
 551               		.cfi_offset 24, -5
 552 000e 9F93      		push r25
 553               	.LCFI4:
 554               		.cfi_def_cfa_offset 7
 555               		.cfi_offset 25, -6
 556               	/* prologue: Signal */
 557               	/* frame size = 0 */
 558               	/* stack size = 6 */
 559               	.L__stack_usage = 6
 319:Shila_Ampel.c ****   msec_cnt++;
 560               		.loc 1 319 0
 561 0010 8091 0000 		lds r24,msec_cnt
 562 0014 9091 0000 		lds r25,msec_cnt+1
 563 0018 0196      		adiw r24,1
 564 001a 9093 0000 		sts msec_cnt+1,r25
 565 001e 8093 0000 		sts msec_cnt,r24
 320:Shila_Ampel.c ****   
 321:Shila_Ampel.c ****   if(sel_trigger == 1)
 566               		.loc 1 321 0
 567 0022 8091 0000 		lds r24,sel_trigger
 568 0026 9091 0000 		lds r25,sel_trigger+1
 569 002a 0197      		sbiw r24,1
 570 002c 01F4      		brne .L23
 322:Shila_Ampel.c **** 	sel_trigger_cnt++;
 571               		.loc 1 322 0
 572 002e 8091 0000 		lds r24,sel_trigger_cnt
 573 0032 9091 0000 		lds r25,sel_trigger_cnt+1
 574 0036 0196      		adiw r24,1
 575 0038 9093 0000 		sts sel_trigger_cnt+1,r25
 576 003c 8093 0000 		sts sel_trigger_cnt,r24
 577               	.L23:
 323:Shila_Ampel.c ****   
 324:Shila_Ampel.c ****   sel_led_cnt++;
 578               		.loc 1 324 0
 579 0040 8091 0000 		lds r24,sel_led_cnt
 580 0044 9091 0000 		lds r25,sel_led_cnt+1
 581 0048 0196      		adiw r24,1
 582 004a 9093 0000 		sts sel_led_cnt+1,r25
 583 004e 8093 0000 		sts sel_led_cnt,r24
 325:Shila_Ampel.c ****   traffic_cnt++;
 584               		.loc 1 325 0
 585 0052 8091 0000 		lds r24,traffic_cnt
 586 0056 9091 0000 		lds r25,traffic_cnt+1
 587 005a 0196      		adiw r24,1
 588 005c 9093 0000 		sts traffic_cnt+1,r25
 589 0060 8093 0000 		sts traffic_cnt,r24
 326:Shila_Ampel.c ****   
 327:Shila_Ampel.c ****   if (msec_cnt == 1000)
 590               		.loc 1 327 0
 591 0064 8091 0000 		lds r24,msec_cnt
 592 0068 9091 0000 		lds r25,msec_cnt+1
 593 006c 883E      		cpi r24,-24
 594 006e 9340      		sbci r25,3
 595 0070 01F4      		brne .L22
 328:Shila_Ampel.c ****   {
 329:Shila_Ampel.c **** 	msec_cnt = 0;
 596               		.loc 1 329 0
 597 0072 1092 0000 		sts msec_cnt+1,__zero_reg__
 598 0076 1092 0000 		sts msec_cnt,__zero_reg__
 330:Shila_Ampel.c **** 	sec_cnt++;
 599               		.loc 1 330 0
 600 007a 8091 0000 		lds r24,sec_cnt
 601 007e 9091 0000 		lds r25,sec_cnt+1
 602 0082 0196      		adiw r24,1
 603 0084 9093 0000 		sts sec_cnt+1,r25
 604 0088 8093 0000 		sts sec_cnt,r24
 331:Shila_Ampel.c **** 	if(toggle_led == 0)
 605               		.loc 1 331 0
 606 008c 8091 0000 		lds r24,toggle_led
 607 0090 9091 0000 		lds r25,toggle_led+1
 608 0094 892B      		or r24,r25
 609 0096 01F4      		brne .L25
 332:Shila_Ampel.c **** 	{
 333:Shila_Ampel.c **** 		LED_ON;
 610               		.loc 1 333 0
 611 0098 5E9A      		sbi 0xb,6
 334:Shila_Ampel.c **** 		toggle_led = 1;
 612               		.loc 1 334 0
 613 009a 81E0      		ldi r24,lo8(1)
 614 009c 90E0      		ldi r25,0
 615 009e 9093 0000 		sts toggle_led+1,r25
 616 00a2 8093 0000 		sts toggle_led,r24
 617 00a6 00C0      		rjmp .L22
 618               	.L25:
 335:Shila_Ampel.c **** 	}
 336:Shila_Ampel.c **** 	else
 337:Shila_Ampel.c **** 	{
 338:Shila_Ampel.c **** 		LED_OFF;
 619               		.loc 1 338 0
 620 00a8 5E98      		cbi 0xb,6
 339:Shila_Ampel.c **** 		toggle_led = 0;
 621               		.loc 1 339 0
 622 00aa 1092 0000 		sts toggle_led+1,__zero_reg__
 623 00ae 1092 0000 		sts toggle_led,__zero_reg__
 624               	.L22:
 625               	/* epilogue start */
 340:Shila_Ampel.c **** 	}
 341:Shila_Ampel.c ****   }
 342:Shila_Ampel.c **** }
 626               		.loc 1 342 0
 627 00b2 9F91      		pop r25
 628 00b4 8F91      		pop r24
 629 00b6 2F91      		pop r18
 630 00b8 0F90      		pop r0
 631 00ba 0FBE      		out __SREG__,r0
 632 00bc 0F90      		pop r0
 633 00be 1F90      		pop r1
 634 00c0 1895      		reti
 635               		.cfi_endproc
 636               	.LFE8:
 638               		.section	.text.__vector_1,"ax",@progbits
 639               	.global	__vector_1
 641               	__vector_1:
 642               	.LFB9:
 343:Shila_Ampel.c **** 
 344:Shila_Ampel.c **** ISR(INT0_vect)
 345:Shila_Ampel.c **** {
 643               		.loc 1 345 0
 644               		.cfi_startproc
 645 0000 1F92      		push r1
 646               	.LCFI5:
 647               		.cfi_def_cfa_offset 3
 648               		.cfi_offset 1, -2
 649 0002 0F92      		push r0
 650               	.LCFI6:
 651               		.cfi_def_cfa_offset 4
 652               		.cfi_offset 0, -3
 653 0004 0FB6      		in r0,__SREG__
 654 0006 0F92      		push r0
 655 0008 1124      		clr __zero_reg__
 656 000a 8F93      		push r24
 657               	.LCFI7:
 658               		.cfi_def_cfa_offset 5
 659               		.cfi_offset 24, -4
 660 000c 9F93      		push r25
 661               	.LCFI8:
 662               		.cfi_def_cfa_offset 6
 663               		.cfi_offset 25, -5
 664               	/* prologue: Signal */
 665               	/* frame size = 0 */
 666               	/* stack size = 5 */
 667               	.L__stack_usage = 5
 346:Shila_Ampel.c **** 	toggle_green = 1;
 668               		.loc 1 346 0
 669 000e 81E0      		ldi r24,lo8(1)
 670 0010 90E0      		ldi r25,0
 671 0012 9093 0000 		sts toggle_green+1,r25
 672 0016 8093 0000 		sts toggle_green,r24
 673               	/* epilogue start */
 347:Shila_Ampel.c **** }
 674               		.loc 1 347 0
 675 001a 9F91      		pop r25
 676 001c 8F91      		pop r24
 677 001e 0F90      		pop r0
 678 0020 0FBE      		out __SREG__,r0
 679 0022 0F90      		pop r0
 680 0024 1F90      		pop r1
 681 0026 1895      		reti
 682               		.cfi_endproc
 683               	.LFE9:
 685               		.section	.text.__vector_2,"ax",@progbits
 686               	.global	__vector_2
 688               	__vector_2:
 689               	.LFB10:
 348:Shila_Ampel.c **** 
 349:Shila_Ampel.c **** ISR(INT1_vect)
 350:Shila_Ampel.c **** {
 690               		.loc 1 350 0
 691               		.cfi_startproc
 692 0000 1F92      		push r1
 693               	.LCFI9:
 694               		.cfi_def_cfa_offset 3
 695               		.cfi_offset 1, -2
 696 0002 0F92      		push r0
 697               	.LCFI10:
 698               		.cfi_def_cfa_offset 4
 699               		.cfi_offset 0, -3
 700 0004 0FB6      		in r0,__SREG__
 701 0006 0F92      		push r0
 702 0008 1124      		clr __zero_reg__
 703 000a 8F93      		push r24
 704               	.LCFI11:
 705               		.cfi_def_cfa_offset 5
 706               		.cfi_offset 24, -4
 707 000c 9F93      		push r25
 708               	.LCFI12:
 709               		.cfi_def_cfa_offset 6
 710               		.cfi_offset 25, -5
 711               	/* prologue: Signal */
 712               	/* frame size = 0 */
 713               	/* stack size = 5 */
 714               	.L__stack_usage = 5
 351:Shila_Ampel.c **** 	toggle_red = 1;
 715               		.loc 1 351 0
 716 000e 81E0      		ldi r24,lo8(1)
 717 0010 90E0      		ldi r25,0
 718 0012 9093 0000 		sts toggle_red+1,r25
 719 0016 8093 0000 		sts toggle_red,r24
 720               	/* epilogue start */
 352:Shila_Ampel.c **** }
 721               		.loc 1 352 0
 722 001a 9F91      		pop r25
 723 001c 8F91      		pop r24
 724 001e 0F90      		pop r0
 725 0020 0FBE      		out __SREG__,r0
 726 0022 0F90      		pop r0
 727 0024 1F90      		pop r1
 728 0026 1895      		reti
 729               		.cfi_endproc
 730               	.LFE10:
 732               		.section	.text.__vector_3,"ax",@progbits
 733               	.global	__vector_3
 735               	__vector_3:
 736               	.LFB11:
 353:Shila_Ampel.c **** 
 354:Shila_Ampel.c **** ISR(INT2_vect)
 355:Shila_Ampel.c **** {
 737               		.loc 1 355 0
 738               		.cfi_startproc
 739 0000 1F92      		push r1
 740               	.LCFI13:
 741               		.cfi_def_cfa_offset 3
 742               		.cfi_offset 1, -2
 743 0002 0F92      		push r0
 744               	.LCFI14:
 745               		.cfi_def_cfa_offset 4
 746               		.cfi_offset 0, -3
 747 0004 0FB6      		in r0,__SREG__
 748 0006 0F92      		push r0
 749 0008 1124      		clr __zero_reg__
 750 000a 8F93      		push r24
 751               	.LCFI15:
 752               		.cfi_def_cfa_offset 5
 753               		.cfi_offset 24, -4
 754 000c 9F93      		push r25
 755               	.LCFI16:
 756               		.cfi_def_cfa_offset 6
 757               		.cfi_offset 25, -5
 758               	/* prologue: Signal */
 759               	/* frame size = 0 */
 760               	/* stack size = 5 */
 761               	.L__stack_usage = 5
 356:Shila_Ampel.c **** 	toggle_yellow = 1;
 762               		.loc 1 356 0
 763 000e 81E0      		ldi r24,lo8(1)
 764 0010 90E0      		ldi r25,0
 765 0012 9093 0000 		sts toggle_yellow+1,r25
 766 0016 8093 0000 		sts toggle_yellow,r24
 357:Shila_Ampel.c **** 	sel_trigger = 1;
 767               		.loc 1 357 0
 768 001a 9093 0000 		sts sel_trigger+1,r25
 769 001e 8093 0000 		sts sel_trigger,r24
 770               	/* epilogue start */
 358:Shila_Ampel.c **** }
 771               		.loc 1 358 0
 772 0022 9F91      		pop r25
 773 0024 8F91      		pop r24
 774 0026 0F90      		pop r0
 775 0028 0FBE      		out __SREG__,r0
 776 002a 0F90      		pop r0
 777 002c 1F90      		pop r1
 778 002e 1895      		reti
 779               		.cfi_endproc
 780               	.LFE11:
 782               	.global	toggle_red
 783               		.section .bss
 786               	toggle_red:
 787 0000 0000      		.zero	2
 788               	.global	toggle_yellow
 791               	toggle_yellow:
 792 0002 0000      		.zero	2
 793               	.global	toggle_green
 796               	toggle_green:
 797 0004 0000      		.zero	2
 798               	.global	toggle_led
 801               	toggle_led:
 802 0006 0000      		.zero	2
 803               	.global	traffic_cnt
 806               	traffic_cnt:
 807 0008 0000      		.zero	2
 808               	.global	light
 809               		.data
 812               	light:
 813 0000 01        		.byte	1
 814               	.global	sel_y
 815               		.section .bss
 818               	sel_y:
 819 000a 0000      		.zero	2
 820               	.global	sel_led_cnt
 823               	sel_led_cnt:
 824 000c 0000      		.zero	2
 825               	.global	sel_trigger
 828               	sel_trigger:
 829 000e 0000      		.zero	2
 830               	.global	sel_trigger_cnt
 833               	sel_trigger_cnt:
 834 0010 0000      		.zero	2
 835               	.global	sec_cnt
 838               	sec_cnt:
 839 0012 0000      		.zero	2
 840               	.global	msec_cnt
 843               	msec_cnt:
 844 0014 0000      		.zero	2
 845               		.text
 846               	.Letext0:
 847               		.file 3 "/usr/lib/avr/include/stdint.h"
 848               		.file 4 "usb_debug_only.h"
DEFINED SYMBOLS
                            *ABS*:00000000 Shila_Ampel.c
     /tmp/cc7uqlF8.s:2      *ABS*:0000003e __SP_H__
     /tmp/cc7uqlF8.s:3      *ABS*:0000003d __SP_L__
     /tmp/cc7uqlF8.s:4      *ABS*:0000003f __SREG__
     /tmp/cc7uqlF8.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc7uqlF8.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc7uqlF8.s:13     .text.startup.main:00000000 main
     /tmp/cc7uqlF8.s:812    .data:00000000 light
     /tmp/cc7uqlF8.s:833    .bss:00000010 sel_trigger_cnt
     /tmp/cc7uqlF8.s:823    .bss:0000000c sel_led_cnt
     /tmp/cc7uqlF8.s:806    .bss:00000008 traffic_cnt
     /tmp/cc7uqlF8.s:786    .bss:00000000 toggle_red
     /tmp/cc7uqlF8.s:791    .bss:00000002 toggle_yellow
     /tmp/cc7uqlF8.s:796    .bss:00000004 toggle_green
     /tmp/cc7uqlF8.s:828    .bss:0000000e sel_trigger
     /tmp/cc7uqlF8.s:529    .text.__vector_21:00000000 __vector_21
     /tmp/cc7uqlF8.s:843    .bss:00000014 msec_cnt
     /tmp/cc7uqlF8.s:838    .bss:00000012 sec_cnt
     /tmp/cc7uqlF8.s:801    .bss:00000006 toggle_led
     /tmp/cc7uqlF8.s:641    .text.__vector_1:00000000 __vector_1
     /tmp/cc7uqlF8.s:688    .text.__vector_2:00000000 __vector_2
     /tmp/cc7uqlF8.s:735    .text.__vector_3:00000000 __vector_3
     /tmp/cc7uqlF8.s:818    .bss:0000000a sel_y

UNDEFINED SYMBOLS
usb_init
__do_copy_data
__do_clear_bss
